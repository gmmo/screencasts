#include "pch.h"
#include "SoftBodyRenderer.h"
#include "..\Common\DirectXHelper.h"
#include "DDSTextureLoader.h"


using namespace Cloth;
using namespace DirectX;
using namespace GLibAssets;

////////////////////////////////////////////////////////////////////////////////
SoftBodyRenderer::SoftBodyRenderer(
    const std::shared_ptr<DX::DeviceResources>& deviceResources,
    ObjectShape objectShape,
    FileLoad& fileUtil,
    const std::wstring& filename,
    XMFLOAT3 worldTranslation) :
    LightTexRenderer(deviceResources, objectShape, fileUtil, filename)
{
    m_objectShape = objectShape;

    // Build stick constraints based on the model geometry
    m_numParticles = m_objectVertexCount;

    // make a copy of sorce data
    m_x = new GLibAssets::VertexPositionColorNormalTexture[m_objectVertexCount];
    memcpy(m_x, this->m_pObjectVertices, sizeof(VertexPositionColorNormalTexture)*m_objectVertexCount);

    for (uint32_t ii = 0; ii < m_objectIndexCount; ii += 3)
    {
        // Get the tri indexes
        unsigned short i0 = m_pObjectIndices[ii];
        unsigned short i1 = m_pObjectIndices[ii + 1];
        unsigned short i2 = m_pObjectIndices[ii + 2];

        // Add the edges of each triangle as contraint
        // but do not repeat constraints
        unsigned short triEdges[] =
        {
            i0, i1,
            i1, i2,
            i2, i0,
        };

        for (uint32_t jj = 0; jj < sizeof(triEdges) / sizeof(unsigned short); jj += 2)
        {
            StickConstraint* edge;
            uint32_t iA = triEdges[jj];
            uint32_t iB = triEdges[jj + 1];
            edge = FindConstraint(iA, iB);
            if (nullptr == edge)
            {
                VertexPositionColorNormalTexture* pA = &m_pObjectVertices[iA];
                VertexPositionColorNormalTexture* pB = &m_pObjectVertices[iB];

                // Calculate the rest length
                XMVECTOR    vA = XMLoadFloat3(&pA->pos);
                XMVECTOR    vB = XMLoadFloat3(&pB->pos);
                float       deltalength = XMVectorGetX(XMVector3Length(vB - vA));
                StickConstraint* pStick = new StickConstraint(iA, iB, deltalength);
                m_stickConstraint.push_back(pStick);
            }
        }
    }   // for (uint32_t ii = 0; ii < m_objectIndexCount; ii+=3)

    m_centerOfMass = XMFLOAT3(0.f, 0.f, 0.f);
    XMVECTOR centerOfMass = XMLoadFloat3(&m_centerOfMass);

    if ((objectShape == ObjectShape::SphereTex) ||
        (objectShape == ObjectShape::TorusTex))
    {
        for (uint32_t ii = 0; ii < m_numParticles; ii++)
        {
            XMVECTOR x = XMLoadFloat3(&m_x[ii].pos);

            float deltalength = XMVectorGetX(XMVector3Length(x - centerOfMass));

            StickConstraintCenterOfMass* pStick = new StickConstraintCenterOfMass(ii, deltalength);
            m_stickConstraintCenterOfMass.push_back(pStick);
        }
    }

    // Setup the other arrays
    m_oldx = new XMFLOAT3[m_numParticles];
    m_a = new XMFLOAT3[m_numParticles];

    memset(m_a, 0x00, sizeof(XMFLOAT3)*m_numParticles);
    for (uint32_t ii = 0; ii < m_numParticles; ii++)
    {
        m_oldx[ii] = m_pObjectVertices[ii].pos;
    }

    // Compute edge constraint using distance betweenthe points and
    // a base line. Noticed that the model was generated by blender,
    // I need to do it procedurally.
    // http://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html

    if ((objectShape == ObjectShape::PlaneTex) ||
        (objectShape == ObjectShape::HiResPlaneTex))
    {

        XMVECTOR    x0; // point to be tested
        XMVECTOR    x1 = XMLoadFloat3(&XMFLOAT3(0.f, 0.f, -1.f));
        XMVECTOR    x2 = XMLoadFloat3(&XMFLOAT3(1.f, 0.f, -1.f));

        for (uint32_t ii = 0; ii < m_numParticles; ii++)
        {
            x0 = XMLoadFloat3(&m_oldx[ii]);

            XMVECTOR x10 = x0 - x1;
            XMVECTOR x20 = x0 - x2;
            XMVECTOR numerator = XMVector3Cross(x10, x20);
            XMVECTOR denominator = x2 - x1;
            XMVECTOR distance = XMVector3Length(numerator) / XMVector3Length(denominator);
            float d = XMVectorGetX(distance);
            if (d < 0.000000001f)
            {
                EdgeConstraint* pEdge = new EdgeConstraint(m_oldx[ii], ii);
                m_edgeConstraint.push_back(pEdge);
            }

            //std::wstring   timeStepStr = std::to_wstring(d) + L"\n";
            //OutputDebugString(timeStepStr.c_str());
        }
    }

    // translate all particles and constraints positions
    XMVECTOR worldTranslationVec = XMLoadFloat3(&worldTranslation);
    centerOfMass += worldTranslationVec;
    XMStoreFloat3(&m_centerOfMass, centerOfMass);
    m_centerOfMassOld = m_centerOfMass;

    for (auto it = m_edgeConstraint.begin(); it != m_edgeConstraint.end(); ++it)
    {
        EdgeConstraint* pEdge = *it;
        XMVECTOR pos = XMLoadFloat3(&pEdge->pos);
        pos += worldTranslationVec;
        XMStoreFloat3(&pEdge->pos, pos);
    }

    for (uint32_t ii = 0; ii < m_numParticles; ii++)
    {
        XMVECTOR x      = XMLoadFloat3(&m_x[ii].pos);
        XMVECTOR oldx   = XMLoadFloat3(&m_oldx[ii]);

        x += worldTranslationVec;
        oldx += worldTranslationVec;

        XMStoreFloat3(&m_x[ii].pos, x);
        XMStoreFloat3(&m_oldx[ii], oldx);
    }

    m_vGravity = XMFLOAT3(0.f, -3.0f, 0.f);
}

StickConstraint* SoftBodyRenderer::FindConstraint(unsigned short pA, unsigned short pB)
{
    StickConstraint* constraint = nullptr;

    for (auto it = m_stickConstraint.begin(); it != m_stickConstraint.end(); ++it)
    {
        StickConstraint* constraintTest = *it;

        if ((constraintTest->particleA == pA &&
            constraintTest->particleB == pB) ||
            (constraintTest->particleA == pB &&
            constraintTest->particleB == pA))
        {
            std::string msgStr = "Constraint: (" +
                std::to_string(pA) + "," +
                std::to_string(pB) + ") already added" + 
                "\n";
            OutputDebugStringA(msgStr.c_str());
            constraint = constraintTest;
            break;
        }
    }

    return constraint;
}

////////////////////////////////////////////////////////////////////////////////
void SoftBodyRenderer::Init(
    DirectX::XMFLOAT4X4 model,
    DirectX::XMFLOAT4X4 view,
    DirectX::XMFLOAT4X4 projection)
{
    ObjectRenderer::Init(model, view, projection);
}


////////////////////////////////////////////////////////////////////////////////
// Called once per frame updating the model and view matrices.
void SoftBodyRenderer::Update(CameraData* pCamera)
{
    ObjectRenderer::Update(pCamera);
}

////////////////////////////////////////////////////////////////////////////////
void SoftBodyRenderer::Render()
{
    auto context = m_deviceResources->GetD3DDeviceContext();

    // Prepare the constant buffer to send it to the graphics device.
    context->UpdateSubresource(
        m_cbTransform.Get(),
        0,
        NULL,
        &m_cbTransformData,
        0,
        0
        );

    // Update light constant buffers
    UpdateLightCBuff();

    /////////////////////////////////////////////////////////////////////////////////a
    UINT stride = sizeof(GLibAssets::VertexPositionColorNormalTexture);
    UINT offset = 0;
    context->IASetVertexBuffers(
        0,
        1,
        m_vertexBuffer.GetAddressOf(),
        &stride,
        &offset
        );

    context->IASetIndexBuffer(
        m_indexBuffer.Get(),
        DXGI_FORMAT_R16_UINT, // Each index is one 16-bit unsigned integer (short).
        0
        );

    context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

    context->IASetInputLayout(m_inputLayout.Get());

    // Attach our vertex shader.
    context->VSSetShader(
        m_vertexShader.Get(),
        nullptr,
        0
        );

    // Send the constant buffer to the graphics device.
    context->VSSetConstantBuffers(
        0,
        1,
        m_cbTransform.GetAddressOf()
        );

    // Attach our pixel shader.
    context->PSSetShader(
        m_pixelShader.Get(),
        nullptr,
        0
        );

    ID3D11ShaderResourceView*   pSRV        = m_textureView.Get();
    context->PSSetShaderResources(8, 1, &pSRV);

    ID3D11SamplerState*         pSampler    = m_textureSamplerLinear.Get();
    context->PSSetSamplers(9, 1, &pSampler);

    context->RSSetState(m_NoCullRS.Get());


    // Draw the objects.
    context->DrawIndexed(
        m_objectIndexCount,
        0,
        0
        );

    //context->RSSetState(0);
}

////////////////////////////////////////////////////////////////////////////////
void SoftBodyRenderer::Create()
{
    // Load shaders asynchronously.
    auto fileData = m_fileUtil.ReadFileSync(L"LightTexVS.cso");

    // After the vertex shader file is loaded, create the shader and input layout.
    DX::ThrowIfFailed(
        m_deviceResources->GetD3DDevice()->CreateVertexShader(
            &fileData[0],
            fileData.size(),
            nullptr,
            &m_vertexShader
            )
        );

    static const D3D11_INPUT_ELEMENT_DESC vertexDesc[] =
    {
        { "POSITION",   0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0,                               D3D11_INPUT_PER_VERTEX_DATA, 0 },
        { "COLOR",      0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT,    D3D11_INPUT_PER_VERTEX_DATA, 0 },
        { "NORMAL",     0, DXGI_FORMAT_R32G32B32_FLOAT, 0, D3D11_APPEND_ALIGNED_ELEMENT,    D3D11_INPUT_PER_VERTEX_DATA, 0 },
        { "TEXCOORD",   0, DXGI_FORMAT_R32G32_FLOAT,    0, D3D11_APPEND_ALIGNED_ELEMENT,    D3D11_INPUT_PER_VERTEX_DATA, 0 },
    };

    DX::ThrowIfFailed(
        m_deviceResources->GetD3DDevice()->CreateInputLayout(
            vertexDesc,
            ARRAYSIZE(vertexDesc),
            &fileData[0],
            fileData.size(),
            &m_inputLayout
            )
        );

    fileData = m_fileUtil.ReadFileSync(L"LightTexPS.cso");

    // After the pixel shader file is loaded, create the shader and constant buffer.
    DX::ThrowIfFailed(
        m_deviceResources->GetD3DDevice()->CreatePixelShader(
            &fileData[0],
            fileData.size(),
            nullptr,
            &m_pixelShader
            )
        );

    CD3D11_BUFFER_DESC cbDescVertex(sizeof(ModelViewProjDataCBuffVS), D3D11_BIND_CONSTANT_BUFFER);
    DX::ThrowIfFailed(
        m_deviceResources->GetD3DDevice()->CreateBuffer(
            &cbDescVertex,
            nullptr,
            &m_cbTransform
            )
        );


    // Create light buffers
    CD3D11_BUFFER_DESC cbDescLight;
    cbDescLight.Usage = D3D11_USAGE_DYNAMIC;
    cbDescLight.ByteWidth = sizeof(LightCBuffPS);
    cbDescLight.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
    cbDescLight.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
    cbDescLight.MiscFlags = 0;
    cbDescLight.StructureByteStride = 0;
    DX::ThrowIfFailed(
        m_deviceResources->GetD3DDevice()->CreateBuffer(
            &cbDescLight,
            nullptr,
            &m_cbLight
            )
        );

    // Create material buffer
    CD3D11_BUFFER_DESC cbDescMaterial;
    cbDescMaterial.Usage = D3D11_USAGE_DYNAMIC;
    cbDescMaterial.ByteWidth = sizeof(MaterialCBuffPS);
    cbDescMaterial.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
    cbDescMaterial.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
    cbDescMaterial.MiscFlags = 0;
    cbDescMaterial.StructureByteStride = 0;

    DX::ThrowIfFailed(
        m_deviceResources->GetD3DDevice()->CreateBuffer(
            &cbDescMaterial,
            nullptr,
            &m_cbMaterial
            )
        );

    D3D11_SUBRESOURCE_DATA vertexBufferData = { 0 };
    vertexBufferData.pSysMem = m_pObjectVertices;
    vertexBufferData.SysMemPitch = 0;
    vertexBufferData.SysMemSlicePitch = 0;
    CD3D11_BUFFER_DESC vertexBufferDesc(m_objectVertexBufferSize, D3D11_BIND_VERTEX_BUFFER);

    vertexBufferDesc.Usage = D3D11_USAGE_DYNAMIC;
    vertexBufferDesc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;

    DX::ThrowIfFailed(
        m_deviceResources->GetD3DDevice()->CreateBuffer(
            &vertexBufferDesc,
            &vertexBufferData,
            &m_vertexBuffer
            )
        );

    D3D11_SUBRESOURCE_DATA indexBufferData = { 0 };
    indexBufferData.pSysMem = m_pObjectIndices;
    indexBufferData.SysMemPitch = 0;
    indexBufferData.SysMemSlicePitch = 0;
    CD3D11_BUFFER_DESC indexBufferDesc(sizeof(unsigned short)*m_objectIndexCount, D3D11_BIND_INDEX_BUFFER);
    DX::ThrowIfFailed(
        m_deviceResources->GetD3DDevice()->CreateBuffer(
            &indexBufferDesc,
            &indexBufferData,
            &m_indexBuffer
            )
        );

    /////////////////////////////////////////////////////////////////////////////////
    // Update material constant buffer
    UpdateMaterialCBuff();
}

////////////////////////////////////////////////////////////////////////////////
void SoftBodyRenderer::Destroy()
{
    ObjectRenderer::Destroy();

    m_cbTransform.Reset();
    m_cbLight.Reset();
    m_cbMaterial.Reset();
}

////////////////////////////////////////////////////////////////////////////////
void SoftBodyRenderer::Update(DX::StepTimer const& timer)
{
    // Get the time step
    float timeStep = static_cast<float>(timer.GetElapsedSeconds());
    std::wstring   timeStepStr = std::to_wstring(timeStep) + L"\n";
    //OutputDebugString(timeStepStr.c_str());

    AccumulateForces();
    Verlet(timeStep);
    SatisfyConstraints();

    UpdateVertices();
}

void SoftBodyRenderer::UpdateVertices()
{
    SceneRenderer::CreateVertexNormals(
        m_pObjectIndices,
        m_objectIndexCount,
        m_x,
        m_objectVertexCount);

    auto context = m_deviceResources->GetD3DDeviceContext();

    // Copy particle positions to vertex positions
    D3D11_MAPPED_SUBRESOURCE mappedResource;
    ZeroMemory(&mappedResource, sizeof(D3D11_MAPPED_SUBRESOURCE));

    // Disable GPU access to the vertex buffer data.
    auto m_d3dContext = m_deviceResources->GetD3DDeviceContext();
    m_d3dContext->Map(m_vertexBuffer.Get(), 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource);

    memcpy(mappedResource.pData, m_x, m_numParticles*sizeof(VertexPositionColorNormalTexture));

    // Reenable GPU access to the vertex buffer data.
    m_d3dContext->Unmap(m_vertexBuffer.Get(), 0);
}


void SoftBodyRenderer::Verlet(float fTimeStep)
{
    float f1 = 0.99f;
    float f2 = 0.99f;

    for (uint32_t i = 0; i < m_numParticles; i++)
    {
        XMVECTOR x = XMLoadFloat3(&m_x[i].pos);
        XMVECTOR temp = x;
        XMVECTOR oldx = XMLoadFloat3(&m_oldx[i]);
        XMVECTOR a = XMLoadFloat3(&m_a[i]);
        x += f1*x - f2*oldx + a*fTimeStep*fTimeStep;
        XMStoreFloat3(&m_x[i].pos, x);
        XMStoreFloat3(&m_oldx[i], temp);
    }

    // Move center of mass
    XMVECTOR x = XMLoadFloat3(&m_centerOfMass);
    XMVECTOR temp = x;
    XMVECTOR oldx = XMLoadFloat3(&m_centerOfMassOld);
    XMVECTOR a = XMLoadFloat3(&m_vGravity);
    x += f1*x - f2*oldx + a*fTimeStep*fTimeStep;
    XMStoreFloat3(&m_centerOfMass, x);
    XMStoreFloat3(&m_centerOfMassOld, temp);
}

void SoftBodyRenderer::NudgeCenterOfMass(DirectX::XMFLOAT3 nudge)
{
    this->m_centerOfMass.x += nudge.x;
    this->m_centerOfMass.y += nudge.y;
    this->m_centerOfMass.z += nudge.z;
}

void SoftBodyRenderer::SatisfyConstraints()
{
    // Satisfy C1
    for (auto it = m_edgeConstraint.begin(); it != m_edgeConstraint.end(); ++it)
    {
        EdgeConstraint* pEdge = *it;
        m_x[pEdge->index].pos = pEdge->pos;
    }

    // Satisfy ground constraint
    for (uint32_t i = 0; i < m_numParticles; i++)
    {

        if (m_x[i].pos.y < 0.f)
        {
            m_x[i].pos.y = 0.f;
        }
    }

    if (this->m_centerOfMass.y < 0.5)
    {
        this->m_centerOfMass.y = 0.5;
    }


    float limit = 3.5f;
    if (m_centerOfMass.x < -limit) m_centerOfMass.x = -limit;
    if (m_centerOfMass.x > limit) m_centerOfMass.x = limit;
    if (m_centerOfMass.z < -limit) m_centerOfMass.z = -limit;
    if (m_centerOfMass.z > limit) m_centerOfMass.z = limit;


    for (uint32_t j = 0; j < m_numIterations; j++)
    {
        // satisfy stick constraint (C2)
        for (auto it = m_stickConstraint.begin(); it != m_stickConstraint.end(); ++it)
        {
            StickConstraint* pStick = *it;

            XMVECTOR x1 = XMLoadFloat3(&m_x[pStick->particleA].pos);
            XMVECTOR x2 = XMLoadFloat3(&m_x[pStick->particleB].pos);

            XMVECTOR delta = x2 - x1;

            XMVECTOR deltalength = XMVector3Length(delta);

            float diff = (XMVectorGetX(deltalength) - pStick->restLength) / XMVectorGetX(deltalength);

            x1 += delta*0.5*diff;
            x2 -= delta*0.5*diff;

            XMStoreFloat3(&m_x[pStick->particleA].pos, x1);
            XMStoreFloat3(&m_x[pStick->particleB].pos, x2);
        }

        // satisfy center of mass stick constraint (C3)
        for (auto it = m_stickConstraintCenterOfMass.begin(); it != m_stickConstraintCenterOfMass.end(); ++it)
        {
            StickConstraintCenterOfMass* pStick = *it;

            XMVECTOR x1 = XMLoadFloat3(&m_x[pStick->particle].pos);
            XMVECTOR x2 = XMLoadFloat3(&this->m_centerOfMass);

            XMVECTOR delta = x2 - x1;

            XMVECTOR deltalength = XMVector3Length(delta);

            float diff = (XMVectorGetX(deltalength) - pStick->restLength) / XMVectorGetX(deltalength);

            x1 += delta*diff;
            //x2 -= delta*0.5*diff;

            XMStoreFloat3(&m_x[pStick->particle].pos, x1);
            //XMStoreFloat3(&this->m_centerOfMass, x2);
        }

        // Satisfy sphere constaint (c3)
        if ((m_objectShape == ObjectShape::PlaneTex) ||
            (m_objectShape == ObjectShape::SphereTex) ||
            (m_objectShape == ObjectShape::HiResPlaneTex))
        {

            for (uint32_t ii = 0; ii < m_numParticles; ii++)
            {
                float       bias = 0.01f;
                float       sphereRadius = m_radius + bias;

                XMVECTOR    p = XMLoadFloat3(&m_x[ii].pos);
                XMVECTOR    center = XMLoadFloat3(&m_sphereCenter);
                XMVECTOR    delta = p - center;
                float       deltalength = sqrtf(XMVectorGetX(XMVector3Dot(delta, delta)));

                if (deltalength < sphereRadius)
                {
                    // Project the point to the surface of the sphere
                    XMVECTOR    sphereRadius3 = XMLoadFloat3(&XMFLOAT3(
                        sphereRadius,
                        sphereRadius,
                        sphereRadius));
                    XMVECTOR    dirVector = XMVector3Normalize(delta);
                    XMVECTOR    projected = center + (sphereRadius3)*dirVector;

                    m_x[ii].pos.x = XMVectorGetX(projected);
                    m_x[ii].pos.y = XMVectorGetY(projected);
                    m_x[ii].pos.z = XMVectorGetZ(projected);
                }
            }   // Satisfy sphere constaint (c3)
        }
    }   //for (int j = 0; j<m_numIterations; j++)
}

void SoftBodyRenderer::AccumulateForces()
{
    // All particles are influenced by gravity
    for (uint32_t ii = 0; ii < m_numParticles; ii++)
    {
        m_a[ii] = m_vGravity;
    }
}
